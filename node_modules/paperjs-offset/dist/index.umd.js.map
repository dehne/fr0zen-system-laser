{"version":3,"file":"index.umd.js","sources":["../src/offset_core.ts","../src/index.ts"],"sourcesContent":["import paper from 'paper';\n\nexport type StrokeJoinType = 'miter' | 'bevel' | 'round';\nexport type StrokeCapType = 'round' | 'butt';\nexport type PathType = paper.Path | paper.CompoundPath;\n\ntype HandleType = 'handleIn' | 'handleOut';\n\n/**\n * Offset the start/terminal segment of a bezier curve\n * @param segment segment to offset\n * @param curve curve to offset\n * @param handleNormal the normal of the the line formed of two handles\n * @param offset offset value\n */\nfunction offsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number) {\n  const isFirst = segment.curve === curve;\n  // get offset vector\n  const offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);\n  // get offset point\n  const point = segment.point.add(offsetVector);\n  const newSegment = new paper.Segment(point);\n  // handleOut for start segment & handleIn for terminal segment\n  const handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType;\n  newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2));\n  return newSegment;\n}\n\n/**\n * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.\n * @param curve curve to offset\n * @param offset offset value\n */\nfunction adaptiveOffsetCurve(curve: paper.Curve, offset: number): paper.Segment[] {\n  const hNormal = (new paper.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paper.Point(0, 0),\n    new paper.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);\n  const segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);\n  const segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);\n  // divide && re-offset\n  const offsetCurve = new paper.Curve(segment1, segment2);\n  // if the offset curve is not self intersected, divide it\n  if (offsetCurve.getIntersections(offsetCurve).length === 0) {\n    const threshold = Math.min(Math.abs(offset) / 10, 1);\n    const midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));\n    if (Math.abs(midOffset - Math.abs(offset)) > threshold) {\n      const subCurve = curve.divideAtTime(0.5);\n      if (subCurve != null) {\n        return [...adaptiveOffsetCurve(curve, offset), ...adaptiveOffsetCurve(subCurve, offset)];\n      }\n    }\n  }\n  return [segment1, segment2];\n}\n\n/**\n * Create a round join segment between two adjacent segments.\n */\nfunction makeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number) {\n  const through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))\n    .normalize(Math.abs(radius)).add(originPoint);\n  const arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false });\n  segment1.handleOut = arc.firstSegment.handleOut;\n  segment2.handleIn = arc.lastSegment.handleIn;\n  return arc.segments.length === 3 ? arc.segments[1] : null;\n}\n\nfunction det(p1: paper.Point, p2: paper.Point) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\n/**\n * Get the intersection point of point based lines\n */\nfunction getPointLineIntersections(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point) {\n  const l1 = p1.subtract(p2);\n  const l2 = p3.subtract(p4);\n  const dl1 = det(p1, p2);\n  const dl2 = det(p3, p4);\n  return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));\n}\n\n/**\n * Connect two adjacent bezier curve, each curve is represented by two segments,\n * create different types of joins or simply removal redundant segment.\n */\nfunction connectAdjacentBezier(segments1: paper.Segment[], segments2: paper.Segment[], origin: paper.Segment, joinType: StrokeJoinType, offset: number, limit: number) {\n  const curve1 = new paper.Curve(segments1[0], segments1[1]);\n  const curve2 = new paper.Curve(segments2[0], segments2[1]);\n  const intersection = curve1.getIntersections(curve2);\n  const distance = segments1[1].point.getDistance(segments2[0].point);\n  if (origin.isSmooth()) {\n    segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!);\n    segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!);\n    segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);\n    segments1.pop();\n  } else {\n    if (intersection.length === 0) {\n      if (distance > Math.abs(offset) * 0.1) {\n        // connect\n        switch (joinType) {\n          case 'miter':\n            const join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)),\n              curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));\n            // prevent sharp angle\n            const joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));\n            if (joinOffset < Math.abs(offset) * limit) {\n              segments1.push(new paper.Segment(join));\n            }\n            break;\n          case 'round':\n            const mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);\n            if (mid) {\n              segments1.push(mid);\n            }\n            break;\n          default: break;\n        }\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    } else {\n      const second1 = curve1.divideAt(intersection[0]);\n      if (second1) {\n        const join = second1.segment1;\n        const second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);\n        join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;\n        segments1.pop();\n        segments2[0] = join;\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    }\n  }\n}\n\n/**\n * Connect all the segments together.\n */\nfunction connectBeziers(rawSegments: paper.Segment[][], join: StrokeJoinType, source: paper.Path, offset: number, limit: number) {\n  const originSegments = source.segments;\n  const first = rawSegments[0].slice();\n  for (let i = 0; i < rawSegments.length - 1; ++i) {\n    connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);\n  }\n  if (source.closed) {\n    connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);\n    rawSegments[0][0] = first[0];\n  }\n  return rawSegments;\n}\n\nfunction reduceSingleChildCompoundPath(path: PathType) {\n  if (path.children.length === 1) {\n    path = path.children[0] as paper.Path;\n    path.remove(); // remove from parent, this is critical, or the style attributes will be ignored\n  }\n  return path;\n}\n\n/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */\nfunction normalize(path: PathType, areaThreshold = 0.01) {\n  if (path.closed) {\n    const ignoreArea = Math.abs(path.area * areaThreshold);\n    if (!path.clockwise) {\n      path.reverse();\n    }\n    path = path.unite(path, { insert: false }) as PathType;\n    if (path instanceof paper.CompoundPath) {\n      path.children.filter((c) => Math.abs((c as PathType).area) < ignoreArea).forEach((c) => c.remove());\n      if (path.children.length === 1) {\n        return reduceSingleChildCompoundPath(path);\n      }\n    }\n  }\n  return path;\n}\n\nfunction isSameDirection(partialPath: paper.Path, fullPath: PathType) {\n  const offset1 = partialPath.segments[0].location.offset;\n  const offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;\n  const sampleOffset = (offset1 + offset2) / 3;\n  const originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;\n  const originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;\n  return originOffset1 < originOffset2;\n}\n\n/** Remove self intersection when offset is negative by point direction dectection. */\nfunction removeIntersection(path: PathType) {\n  if (path.closed) {\n    const newPath = path.unite(path, { insert: false }) as PathType;\n    if (newPath instanceof paper.CompoundPath) {\n      (newPath.children as paper.Path[]).filter((c) => {\n        if (c.segments.length > 1) {\n          return !isSameDirection(c, path);\n        } else {\n          return true;\n        }\n      }).forEach((c) => c.remove());\n      return reduceSingleChildCompoundPath(newPath);\n    }\n  }\n  return path;\n}\n\nfunction getSegments(path: PathType) {\n  if (path instanceof paper.CompoundPath) {\n    return path.children.map((c) => (c as paper.Path).segments).flat();\n  } else {\n    return (path as paper.Path).segments;\n  }\n}\n\n/**\n * Remove impossible segments in negative offset condition.\n */\nfunction removeOutsiders(newPath: PathType, path: PathType) {\n  const segments = getSegments(newPath).slice();\n  segments.forEach((segment) => {\n    if (!path.contains(segment.point)) {\n      segment.remove();\n    }\n  });\n}\n\nfunction preparePath(path: paper.Path, offset: number): [paper.Path, number] {\n  const source = path.clone({ insert: false }) as paper.Path;\n  source.reduce({});\n  if (!path.clockwise) {\n    source.reverse();\n    offset = -offset;\n  }\n  return [source, offset];\n}\n\nfunction offsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number): PathType {\n  let source: paper.Path;\n  [source, offset] = preparePath(path, offset);\n  const curves = source.curves.slice();\n  const offsetCurves = curves.map((curve) => adaptiveOffsetCurve(curve, offset)).flat();\n  const raws: paper.Segment[][] = [];\n  for (let i = 0; i < offsetCurves.length; i += 2) {\n    raws.push(offsetCurves.slice(i, i + 2));\n  }\n  const segments = connectBeziers(raws, join, source, offset, limit).flat();\n  const newPath = removeIntersection(new paper.Path({ segments, insert: false, closed: path.closed }));\n  newPath.reduce({});\n  if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {\n    removeOutsiders(newPath, path);\n  }\n  // recovery path\n  if (source.clockwise !== path.clockwise) {\n    newPath.reverse();\n  }\n  return normalize(newPath);\n}\n\nfunction makeRoundCap(from: paper.Segment, to: paper.Segment, offset: number) {\n  const origin = from.point.add(to.point).divide(2);\n  const normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);\n  const through = origin.add(normal);\n  const arc = new paper.Path.Arc({ from: from.point, to: to.point, through, insert: false });\n  return arc.segments;\n}\n\nfunction connectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType): paper.Path {\n  if (outer instanceof paper.CompoundPath) {\n    let cs = outer.children.map((c) => ({ c, a: Math.abs((c as paper.Path).area) }));\n    cs = cs.sort((c1, c2) => c2.a - c1.a);\n    outer = cs[0].c as paper.Path;\n  }\n  const oSegments = (outer as paper.Path).segments.slice();\n  const iSegments = inner.segments.slice();\n  switch (cap) {\n    case 'round':\n      const heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);\n      const tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);\n      const result = new paper.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false });\n      result.reduce({});\n      return result;\n    default: return new paper.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false });\n  }\n}\n\nfunction offsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n  offset = path.clockwise ? offset : -offset;\n  const positiveOffset = offsetSimpleShape(path, offset, join, limit);\n  const negativeOffset = offsetSimpleShape(path, -offset, join, limit);\n  if (path.closed) {\n    return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType;\n  } else {\n    let inner = negativeOffset;\n    let holes = new Array<paper.Path>();\n    if (negativeOffset instanceof paper.CompoundPath) {\n      holes = negativeOffset.children.filter((c) => (c as paper.Path).closed) as paper.Path[];\n      holes.forEach((h) => h.remove());\n      inner = negativeOffset.children[0] as paper.Path;\n    }\n    inner.reverse();\n    let final = connectSide(positiveOffset, inner as paper.Path, offset, cap) as PathType;\n    if (holes.length > 0) {\n      for (const hole of holes) {\n        final = final.subtract(hole, { insert: false }) as PathType;\n      }\n    }\n    return final;\n  }\n}\n\nfunction getNonSelfItersectionPath(path: PathType) {\n  if (path.closed) {\n    return path.unite(path, { insert: false }) as PathType;\n  }\n  return path;\n}\n\nexport function offsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paper.Path) {\n    result = offsetSimpleShape(nonSIPath, offset, join, limit);\n  } else {\n    const offsetParts = (nonSIPath.children as paper.Path[]).map((c) => {\n      if (c.segments.length > 1) {\n        if (!isSameDirection(c, path)) {\n          c.reverse();\n        }\n        let offseted = offsetSimpleShape(c, offset, join, limit);\n        offseted = normalize(offseted);\n        if (offseted.clockwise !== c.clockwise) {\n          offseted.reverse();\n        }\n        if (offseted instanceof paper.CompoundPath) {\n          offseted.applyMatrix = true;\n          return offseted.children;\n        } else {\n          return offseted;\n        }\n      } else {\n        return null;\n      }\n    });\n    const children = offsetParts.flat().filter((c) => !!c) as paper.Item[];\n    result = new paper.CompoundPath({ children, insert: false });\n  }\n  result.copyAttributes(nonSIPath, false);\n  result.remove();\n  return result;\n}\n\nexport function offsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paper.Path) {\n    result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);\n  } else {\n    const children = (nonSIPath.children as paper.Path[]).flatMap((c) => {\n      return offsetSimpleStroke(c, offset, join, cap, limit);\n    });\n    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType);\n  }\n  result.strokeWidth = 0;\n  result.fillColor = nonSIPath.strokeColor;\n  result.shadowBlur = nonSIPath.shadowBlur;\n  result.shadowColor = nonSIPath.shadowColor;\n  result.shadowOffset = nonSIPath.shadowOffset;\n  return result;\n}\n","import paper from 'paper';\nimport { StrokeJoinType, PathType, StrokeCapType, offsetPath, offsetStroke } from './offset_core';\n\nexport interface OffsetOptions {\n  join?: StrokeJoinType;\n  cap?: StrokeCapType;\n  limit?: number;\n  insert?: boolean;\n}\n\nexport class PaperOffset {\n  public static offset(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    options = options || {};\n    const newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paper.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n\n  public static offsetStroke(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    options = options || {};\n    const newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paper.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n}\n\n/**\n * @deprecated EXTEND existing paper module is not recommend anymore\n */\nexport default function ExtendPaperJs(paperNs: any) {\n  paperNs.Path.prototype.offset = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offset(this, offset, options);\n  };\n\n  paperNs.Path.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offsetStroke(this, offset, options);\n  };\n\n  paperNs.CompoundPath.prototype.offset = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offset(this, offset, options);\n  };\n\n  paperNs.CompoundPath.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offsetStroke(this, offset, options);\n  };\n}\n"],"names":[],"mappings":"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"}