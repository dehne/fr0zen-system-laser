{"version":3,"file":"index.es5.js","sources":["../src/offset_core.ts","../src/index.ts"],"sourcesContent":["import paper from 'paper';\n\nexport type StrokeJoinType = 'miter' | 'bevel' | 'round';\nexport type StrokeCapType = 'round' | 'butt';\nexport type PathType = paper.Path | paper.CompoundPath;\n\ntype HandleType = 'handleIn' | 'handleOut';\n\n/**\n * Offset the start/terminal segment of a bezier curve\n * @param segment segment to offset\n * @param curve curve to offset\n * @param handleNormal the normal of the the line formed of two handles\n * @param offset offset value\n */\nfunction offsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number) {\n  const isFirst = segment.curve === curve;\n  // get offset vector\n  const offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);\n  // get offset point\n  const point = segment.point.add(offsetVector);\n  const newSegment = new paper.Segment(point);\n  // handleOut for start segment & handleIn for terminal segment\n  const handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType;\n  newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2));\n  return newSegment;\n}\n\n/**\n * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.\n * @param curve curve to offset\n * @param offset offset value\n */\nfunction adaptiveOffsetCurve(curve: paper.Curve, offset: number): paper.Segment[] {\n  const hNormal = (new paper.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paper.Point(0, 0),\n    new paper.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);\n  const segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);\n  const segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);\n  // divide && re-offset\n  const offsetCurve = new paper.Curve(segment1, segment2);\n  // if the offset curve is not self intersected, divide it\n  if (offsetCurve.getIntersections(offsetCurve).length === 0) {\n    const threshold = Math.min(Math.abs(offset) / 10, 1);\n    const midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));\n    if (Math.abs(midOffset - Math.abs(offset)) > threshold) {\n      const subCurve = curve.divideAtTime(0.5);\n      if (subCurve != null) {\n        return [...adaptiveOffsetCurve(curve, offset), ...adaptiveOffsetCurve(subCurve, offset)];\n      }\n    }\n  }\n  return [segment1, segment2];\n}\n\n/**\n * Create a round join segment between two adjacent segments.\n */\nfunction makeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number) {\n  const through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))\n    .normalize(Math.abs(radius)).add(originPoint);\n  const arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false });\n  segment1.handleOut = arc.firstSegment.handleOut;\n  segment2.handleIn = arc.lastSegment.handleIn;\n  return arc.segments.length === 3 ? arc.segments[1] : null;\n}\n\nfunction det(p1: paper.Point, p2: paper.Point) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\n/**\n * Get the intersection point of point based lines\n */\nfunction getPointLineIntersections(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point) {\n  const l1 = p1.subtract(p2);\n  const l2 = p3.subtract(p4);\n  const dl1 = det(p1, p2);\n  const dl2 = det(p3, p4);\n  return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));\n}\n\n/**\n * Connect two adjacent bezier curve, each curve is represented by two segments,\n * create different types of joins or simply removal redundant segment.\n */\nfunction connectAdjacentBezier(segments1: paper.Segment[], segments2: paper.Segment[], origin: paper.Segment, joinType: StrokeJoinType, offset: number, limit: number) {\n  const curve1 = new paper.Curve(segments1[0], segments1[1]);\n  const curve2 = new paper.Curve(segments2[0], segments2[1]);\n  const intersection = curve1.getIntersections(curve2);\n  const distance = segments1[1].point.getDistance(segments2[0].point);\n  if (origin.isSmooth()) {\n    segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!);\n    segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!);\n    segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);\n    segments1.pop();\n  } else {\n    if (intersection.length === 0) {\n      if (distance > Math.abs(offset) * 0.1) {\n        // connect\n        switch (joinType) {\n          case 'miter':\n            const join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)),\n              curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));\n            // prevent sharp angle\n            const joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));\n            if (joinOffset < Math.abs(offset) * limit) {\n              segments1.push(new paper.Segment(join));\n            }\n            break;\n          case 'round':\n            const mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);\n            if (mid) {\n              segments1.push(mid);\n            }\n            break;\n          default: break;\n        }\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    } else {\n      const second1 = curve1.divideAt(intersection[0]);\n      if (second1) {\n        const join = second1.segment1;\n        const second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);\n        join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;\n        segments1.pop();\n        segments2[0] = join;\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    }\n  }\n}\n\n/**\n * Connect all the segments together.\n */\nfunction connectBeziers(rawSegments: paper.Segment[][], join: StrokeJoinType, source: paper.Path, offset: number, limit: number) {\n  const originSegments = source.segments;\n  const first = rawSegments[0].slice();\n  for (let i = 0; i < rawSegments.length - 1; ++i) {\n    connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);\n  }\n  if (source.closed) {\n    connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);\n    rawSegments[0][0] = first[0];\n  }\n  return rawSegments;\n}\n\nfunction reduceSingleChildCompoundPath(path: PathType) {\n  if (path.children.length === 1) {\n    path = path.children[0] as paper.Path;\n    path.remove(); // remove from parent, this is critical, or the style attributes will be ignored\n  }\n  return path;\n}\n\n/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */\nfunction normalize(path: PathType, areaThreshold = 0.01) {\n  if (path.closed) {\n    const ignoreArea = Math.abs(path.area * areaThreshold);\n    if (!path.clockwise) {\n      path.reverse();\n    }\n    path = path.unite(path, { insert: false }) as PathType;\n    if (path instanceof paper.CompoundPath) {\n      path.children.filter((c) => Math.abs((c as PathType).area) < ignoreArea).forEach((c) => c.remove());\n      if (path.children.length === 1) {\n        return reduceSingleChildCompoundPath(path);\n      }\n    }\n  }\n  return path;\n}\n\nfunction isSameDirection(partialPath: paper.Path, fullPath: PathType) {\n  const offset1 = partialPath.segments[0].location.offset;\n  const offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;\n  const sampleOffset = (offset1 + offset2) / 3;\n  const originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;\n  const originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;\n  return originOffset1 < originOffset2;\n}\n\n/** Remove self intersection when offset is negative by point direction dectection. */\nfunction removeIntersection(path: PathType) {\n  if (path.closed) {\n    const newPath = path.unite(path, { insert: false }) as PathType;\n    if (newPath instanceof paper.CompoundPath) {\n      (newPath.children as paper.Path[]).filter((c) => {\n        if (c.segments.length > 1) {\n          return !isSameDirection(c, path);\n        } else {\n          return true;\n        }\n      }).forEach((c) => c.remove());\n      return reduceSingleChildCompoundPath(newPath);\n    }\n  }\n  return path;\n}\n\nfunction getSegments(path: PathType) {\n  if (path instanceof paper.CompoundPath) {\n    return path.children.map((c) => (c as paper.Path).segments).flat();\n  } else {\n    return (path as paper.Path).segments;\n  }\n}\n\n/**\n * Remove impossible segments in negative offset condition.\n */\nfunction removeOutsiders(newPath: PathType, path: PathType) {\n  const segments = getSegments(newPath).slice();\n  segments.forEach((segment) => {\n    if (!path.contains(segment.point)) {\n      segment.remove();\n    }\n  });\n}\n\nfunction preparePath(path: paper.Path, offset: number): [paper.Path, number] {\n  const source = path.clone({ insert: false }) as paper.Path;\n  source.reduce({});\n  if (!path.clockwise) {\n    source.reverse();\n    offset = -offset;\n  }\n  return [source, offset];\n}\n\nfunction offsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number): PathType {\n  let source: paper.Path;\n  [source, offset] = preparePath(path, offset);\n  const curves = source.curves.slice();\n  const offsetCurves = curves.map((curve) => adaptiveOffsetCurve(curve, offset)).flat();\n  const raws: paper.Segment[][] = [];\n  for (let i = 0; i < offsetCurves.length; i += 2) {\n    raws.push(offsetCurves.slice(i, i + 2));\n  }\n  const segments = connectBeziers(raws, join, source, offset, limit).flat();\n  const newPath = removeIntersection(new paper.Path({ segments, insert: false, closed: path.closed }));\n  newPath.reduce({});\n  if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {\n    removeOutsiders(newPath, path);\n  }\n  // recovery path\n  if (source.clockwise !== path.clockwise) {\n    newPath.reverse();\n  }\n  return normalize(newPath);\n}\n\nfunction makeRoundCap(from: paper.Segment, to: paper.Segment, offset: number) {\n  const origin = from.point.add(to.point).divide(2);\n  const normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);\n  const through = origin.add(normal);\n  const arc = new paper.Path.Arc({ from: from.point, to: to.point, through, insert: false });\n  return arc.segments;\n}\n\nfunction connectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType): paper.Path {\n  if (outer instanceof paper.CompoundPath) {\n    let cs = outer.children.map((c) => ({ c, a: Math.abs((c as paper.Path).area) }));\n    cs = cs.sort((c1, c2) => c2.a - c1.a);\n    outer = cs[0].c as paper.Path;\n  }\n  const oSegments = (outer as paper.Path).segments.slice();\n  const iSegments = inner.segments.slice();\n  switch (cap) {\n    case 'round':\n      const heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);\n      const tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);\n      const result = new paper.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false });\n      result.reduce({});\n      return result;\n    default: return new paper.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false });\n  }\n}\n\nfunction offsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n  offset = path.clockwise ? offset : -offset;\n  const positiveOffset = offsetSimpleShape(path, offset, join, limit);\n  const negativeOffset = offsetSimpleShape(path, -offset, join, limit);\n  if (path.closed) {\n    return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType;\n  } else {\n    let inner = negativeOffset;\n    let holes = new Array<paper.Path>();\n    if (negativeOffset instanceof paper.CompoundPath) {\n      holes = negativeOffset.children.filter((c) => (c as paper.Path).closed) as paper.Path[];\n      holes.forEach((h) => h.remove());\n      inner = negativeOffset.children[0] as paper.Path;\n    }\n    inner.reverse();\n    let final = connectSide(positiveOffset, inner as paper.Path, offset, cap) as PathType;\n    if (holes.length > 0) {\n      for (const hole of holes) {\n        final = final.subtract(hole, { insert: false }) as PathType;\n      }\n    }\n    return final;\n  }\n}\n\nfunction getNonSelfItersectionPath(path: PathType) {\n  if (path.closed) {\n    return path.unite(path, { insert: false }) as PathType;\n  }\n  return path;\n}\n\nexport function offsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paper.Path) {\n    result = offsetSimpleShape(nonSIPath, offset, join, limit);\n  } else {\n    const offsetParts = (nonSIPath.children as paper.Path[]).map((c) => {\n      if (c.segments.length > 1) {\n        if (!isSameDirection(c, path)) {\n          c.reverse();\n        }\n        let offseted = offsetSimpleShape(c, offset, join, limit);\n        offseted = normalize(offseted);\n        if (offseted.clockwise !== c.clockwise) {\n          offseted.reverse();\n        }\n        if (offseted instanceof paper.CompoundPath) {\n          offseted.applyMatrix = true;\n          return offseted.children;\n        } else {\n          return offseted;\n        }\n      } else {\n        return null;\n      }\n    });\n    const children = offsetParts.flat().filter((c) => !!c) as paper.Item[];\n    result = new paper.CompoundPath({ children, insert: false });\n  }\n  result.copyAttributes(nonSIPath, false);\n  result.remove();\n  return result;\n}\n\nexport function offsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paper.Path) {\n    result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);\n  } else {\n    const children = (nonSIPath.children as paper.Path[]).flatMap((c) => {\n      return offsetSimpleStroke(c, offset, join, cap, limit);\n    });\n    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType);\n  }\n  result.strokeWidth = 0;\n  result.fillColor = nonSIPath.strokeColor;\n  result.shadowBlur = nonSIPath.shadowBlur;\n  result.shadowColor = nonSIPath.shadowColor;\n  result.shadowOffset = nonSIPath.shadowOffset;\n  return result;\n}\n","import paper from 'paper';\nimport { StrokeJoinType, PathType, StrokeCapType, offsetPath, offsetStroke } from './offset_core';\n\nexport interface OffsetOptions {\n  join?: StrokeJoinType;\n  cap?: StrokeCapType;\n  limit?: number;\n  insert?: boolean;\n}\n\nexport class PaperOffset {\n  public static offset(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    options = options || {};\n    const newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paper.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n\n  public static offsetStroke(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    options = options || {};\n    const newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paper.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n}\n\n/**\n * @deprecated EXTEND existing paper module is not recommend anymore\n */\nexport default function ExtendPaperJs(paperNs: any) {\n  paperNs.Path.prototype.offset = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offset(this, offset, options);\n  };\n\n  paperNs.Path.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offsetStroke(this, offset, options);\n  };\n\n  paperNs.CompoundPath.prototype.offset = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offset(this, offset, options);\n  };\n\n  paperNs.CompoundPath.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offsetStroke(this, offset, options);\n  };\n}\n"],"names":[],"mappings":"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"}